# Solving GEE Binary Mask Export Issues

## The 80KB file problem explained and solved

Your binary masks show correct data in the Google Earth Engine console (1.7M pixels, 885K positive) but export as tiny 80KB files because **masked pixels are excluded from exports**. The solution is simple: use `unmask()` before exporting to assign explicit values to all pixels.

## Why Float64 works but Uint8 fails

The core issue stems from how GEE handles masked pixels during export. When binary masks contain masked (invalid) pixels, these are treated as "no data" and excluded from the export file. **Float64 exports preserve all pixels as floating-point values (21MB files), while Uint8 exports compress masked areas to nothing (80KB files)**. The console display interpolates values for visualization, but exports only write actual data values.

## Primary solution: unmask() before export

The most reliable fix across all sources - official documentation, GitHub repositories, Stack Overflow discussions, and scientific papers - is to use `unmask()` before exporting. This function replaces masked pixels with specified values, ensuring the full spatial extent is written to the export file.

```javascript
// WRONG - Creates 80KB files
var binaryMask = classified.eq(1);  // Creates mask with 1s and masked areas
Export.image.toDrive({
  image: binaryMask.toUint8(),
  description: 'binary_export_fails'
});

// CORRECT - Creates proper sized files
var binaryMask = classified.eq(1);
var exportReady = binaryMask.unmask(0);  // Fill masked pixels with 0
Export.image.toDrive({
  image: exportReady.toUint8(),
  description: 'binary_export_works',
  scale: 30,
  region: geometry,
  maxPixels: 1e13
});
```

## Working examples from verified sources

### Official GEE maizeland classification tutorial

This tutorial demonstrates successful binary classification export for agricultural mapping:

```javascript
// Binary classification (0 = maize, 1 = non-maize)
var trainedRf = ee.Classifier.smileRandomForest({numberOfTrees: 10}).train({
  features: training,
  classProperty: 'class',
  inputProperties: bands
});

var classifiedRf = imageCl.select(bands).classify(trainedRf);

// Successful export using default Float64
Export.image.toDrive({
  image: classifiedRf,  // No explicit type casting needed
  description: 'Maizeland_Binary_Classification',
  scale: 20,
  region: aoi,
  maxPixels: 1e13
});
```

### Water detection binary mask export

From published water detection workflows using NDWI thresholds:

```javascript
// Create binary water mask
var ndwi = image.normalizedDifference(['B3', 'B8']);
var waterMask = ndwi.gte(0.0);  // Binary threshold

// Apply unmask for proper export
var waterExport = waterMask.unmask(0);

// Export with cloud-optimized format
Export.image.toDrive({
  image: waterExport,
  description: 'water_binary_mask',
  scale: 10,
  region: geometry,
  fileFormat: 'GeoTIFF',
  formatOptions: {
    cloudOptimized: true  // Prevents compression issues
  }
});
```

### GitHub verified solution from geemap

The geemap repository (3.7k stars) confirms this solution in issue #1207:

```python
import ee
import geemap

# Python API approach
image = image.clip(roi).unmask()  # Critical unmask step
geemap.ee_export_image(
    image, 
    filename="binary_mask.tif", 
    scale=30, 
    region=roi, 
    file_per_band=False
)
```

## Complete working workflow for binary exports

Based on multiple verified sources, here's a comprehensive workflow that addresses all common issues:

```javascript
// Step 1: Create your binary classification
var binaryMask = image.classify(classifier);  // Or any threshold operation

// Step 2: Diagnostic - verify data before export
var stats = binaryMask.reduceRegion({
  reducer: ee.Reducer.frequencyHistogram(),
  geometry: geometry,
  scale: 30,
  maxPixels: 1e9
});
print('Binary values distribution:', stats);

// Step 3: Prepare for export - handle masked pixels
var exportReady = binaryMask.unmask(0);  // Fill masked areas with 0

// Alternative: Use custom nodata value
// var exportReady = binaryMask.unmask(-9999);

// Step 4: Get projection info for consistency
var projection = image.select(0).projection().getInfo();

// Step 5: Export with optimized parameters
Export.image.toDrive({
  image: exportReady.toUint8(),  // Or keep as Float for larger files
  description: 'binary_mask_export',
  folder: 'GEE_exports',
  scale: 30,
  crs: projection.crs,
  crsTransform: projection.transform,
  region: geometry,
  maxPixels: 1e13,
  fileFormat: 'GeoTIFF',
  formatOptions: {
    cloudOptimized: true,
    noData: 0  // Or -9999 if using custom value
  }
});
```

## Alternative approaches for specific use cases

### Force Float64 for maximum compatibility

If file size isn't a concern, Float64 ensures all data is preserved:

```javascript
var exportFloat = binaryMask.unmask(0).toDouble();
Export.image.toDrive({
  image: exportFloat,
  description: 'binary_float64_export',
  scale: 30,
  region: geometry
});
```

### Multi-band export with explicit mask band

For applications requiring both data and mask information:

```javascript
var dataBand = binaryMask.unmask(0).rename('data');
var maskBand = binaryMask.mask().rename('valid_pixels');
var combined = dataBand.addBands(maskBand);

Export.image.toDrive({
  image: combined.toFloat(),
  description: 'binary_with_mask_band',
  scale: 30,
  region: geometry
});
```

### Handle large areas with tiling parameters

For extensive regions that may cause memory issues:

```javascript
Export.image.toDrive({
  image: binaryMask.unmask(0),
  description: 'large_area_binary',
  scale: 30,
  region: geometry,
  maxPixels: 1e13,
  fileDimensions: [4096, 4096],  // Tile size
  skipEmptyTiles: false,  // Ensure all tiles exported
  tileScale: 8  // Memory optimization
});
```

## Diagnostic code to verify exports

Use these diagnostic approaches to ensure your data is correct before and after export:

```javascript
// Pre-export verification
var pixelCount = binaryMask.select(0).reduceRegion({
  reducer: ee.Reducer.count(),
  geometry: geometry,
  scale: 30,
  maxPixels: 1e9
});
print('Total pixels with data:', pixelCount);

// Check masked pixel count
var maskedCount = binaryMask.mask().not().reduceRegion({
  reducer: ee.Reducer.sum(),
  geometry: geometry,
  scale: 30,
  maxPixels: 1e9
});
print('Masked pixels:', maskedCount);

// Verify value distribution
var histogram = binaryMask.unmask(-1).reduceRegion({
  reducer: ee.Reducer.frequencyHistogram(),
  geometry: geometry,
  scale: 30,
  maxPixels: 1e9
});
print('Value distribution:', histogram);
```

## Common pitfalls and solutions

**Problem 1: Export produces 80KB files despite correct console display**
- **Solution**: Always use `unmask(0)` before export
- **Why**: Masked pixels are excluded from export files

**Problem 2: Uint8 exports fail but Float64 works**
- **Solution**: Either use Float64 or apply `unmask()` before converting to Uint8
- **Why**: Float64 preserves all pixel values including nulls

**Problem 3: Binary values appear stretched or interpolated**
- **Solution**: Use `{min: 0, max: 1}` in visualization parameters
- **Why**: Console applies default stretch that doesn't affect export

**Problem 4: Large areas cause export failures**
- **Solution**: Increase `maxPixels` to `1e13` and add `tileScale: 8`
- **Why**: Default limits are too conservative for large regions

## Conclusion

The 80KB export problem is well-documented with a clear solution: **use `unmask()` before exporting binary masks**. This simple fix ensures all pixels receive explicit values, preventing the compression that creates tiny files. The solution is verified across official Google Earth Engine documentation, active GitHub repositories, community forums, and published scientific papers, with consistent success using the provided code patterns.